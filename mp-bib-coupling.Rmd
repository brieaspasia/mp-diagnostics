---
title: "mp-bib-coupling"
author: "Brie Sherow"
date: "15/07/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load library, include=FALSE}
library(bibliometrix)
```


```{r upload data, eval=TRUE}
getwd()
bib <- convert2df(file = c("./data/scopus2015-2017.bib"), dbsource = "scopus", format = "bibtex") # Convert to a bibliometric data frame

# bib <- convert2df(file = c("./data/scopus2018-2019.bib","./data/scopus2015-2017.bib", "./data/scopus2011-2014.bib","./data/scopus2006-2010.bib", "./data/scopus1999-2005.bib","./data/scopus1970-1998.bib"), dbsource = "scopus", format = "bibtex") # Convert to a bibliometric data frame
names(bib)
#write.csv(bib, "output/bib_as_df.csv", row.names = FALSE) #save this data frame as a csv file
```
**Author's bibliographic coupling** - two authors are bibliographically coupled if they share at leas one reference form their reference lists.  Articles are nodes, shared references are edges.   

```{r  author coupling network, eval=TRUE}
NetMatrix <- biblioNetwork(bib, analysis = "coupling", network = "references", sep = ";")
net = networkPlot(NetMatrix, weighted = NULL, n = 50, Title = "Authors' bibliographic coupling", type = "fruchterman", size = 5, remove.multiple = TRUE, labelsize = 0.8)

```
```{r converting from matrix}
#convert to simple matrix
NetMatrix2 <- as.matrix(NetMatrix)

#convert to data frame
NetMatrix3 <- as.data.frame(NetMatrix2)

#add a column with university names from the rownames
NetMatrix3$Reference <- rownames(NetMatrix3)
head(NetMatrix3$Reference)

#reformat into long df
library(tidyverse)
out <- gather(NetMatrix3, key = COL_NAME, value = Linkscount, -Reference)

#filter out unlinked
out <- out %>%
  filter(Linkscount >0)

#filter out self matches
out <- out[!(out$Reference==out$COL_NAME),]

#clean environment
rm(bib, M, net, NetMatrix, NetMatrix2, NetMatrix3, results, S, test, df2)
```

```{r igraph tutorial}
library(igraph)
#ensuring no duplicated edges or self-loops
gD <- simplify(graph.data.frame(out, directed=FALSE))

vcount(gD)
ecount(gD)

# Calculate degree for all nodes
degAll <- degree(gD, v = V(gD), mode = "all")

# Calculate between-ness for all nodes
betAll <- betweenness(gD, v = V(gD), directed = FALSE) / (((vcount(gD) - 1) * (vcount(gD)-2)) / 2)
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))

# Calculate Dice similarities between all pairs of nodes
dsAll <- similarity.dice(gD, vids = V(gD), mode = "all")

# Add new node/edge attributes based on the calculated node properties/similarities
gD <- set.vertex.attribute(gD, "degree", index = V(gD), value = degAll)
gD <- set.vertex.attribute(gD, "betweenness", index = V(gD), value = betAll.norm)

summary(gD)

#I don't know what this is meant to do???  See line 47 at #https://www.r-bloggers.com/network-visualization-part-2-gephi/
F1 <- function(x) {data.frame(V4 = dsAll[which(V(gD)$name == as.character(x$V1)), which(V(gD)$name == as.character(x$V2))])}
dataSet.ext <- plyr::ddply(out, .variables=c("V1", "V2", "V3"), function(x) data.frame(F1(x)))

```
```{r rgexf}
install.packages("rgexf")
library(rgexf)
```

```{r creating nodes and edges}
# Create a dataframe nodes: 1st column - node ID, 2nd column -node name
nodes_df <- data.frame(ID = c(1:vcount(gD)), NAME = V(gD)$name)
# Create a dataframe edges: 1st column - source node ID, 2nd column -target node ID
edges_df <- as.data.frame(get.edges(gD, c(1:ecount(gD))))


# Define node and edge attributes - these attributes won't be directly used for network visualization, but they may be useful for other network manipulations in Gephi

# Create a dataframe with node attributes: 1st column - attribute 1 (degree), 2nd column - attribute 2 (betweenness)
nodes_att <- data.frame(DEG = V(gD)$degree, BET = V(gD)$betweenness) 

# Create a dataframe with edge attributes: 1st column - attribute 1 (weight), 2nd column - attribute 2 (similarity)
edges_att <- data.frame(WGH = E(gD)$weight, SIM = E(gD)$similarity) 
```

```{r node/edge visual attributes}
# These attributes are the ones used for network visualization

# We'll cheat here, as 2D coordinates result in a better (2D) plot than 3D coordinates
nodes_coord <- as.data.frame(layout.fruchterman.reingold(gD, weights = E(gD)$similarity, dim = 2, niter = 10000))
nodes_coord <- cbind(nodes_coord, rep(0, times = nrow(nodes_coord)))
```

```{r node size}
# We'll interpolate node size based on the node between-ness centrality, using the "approx" function
approxVals <- approx(c(1, 5), n = length(unique(V(gD)$betweenness)))
# Assign a node size for each node based on its betweenness centrality
nodes_size <- sapply(V(gD)$betweenness, function(x) approxVals$y[which(sort(unique(V(gD)$betweenness)) == x)])
```

```{r node colour}
# We'll interpolate node colors based on the node degree
library(grDevices)
F2 <- colorRampPalette(c("#F5DEB3", "#FF0000"), bias = length(unique(V(gD)$degree)), space = "rgb", interpolate = "linear")
# Create a color for each degree
colCodes <- F2(length(unique(V(gD)$degree)))
# Assign a color for each node based on its degree
nodes_col <- sapply(V(gD)$degree, function(x) colCodes[which(sort(unique(V(gD)$degree)) == x)])
# Transform it into a data frame (we have to transpose it first)
nodes_col_df <- as.data.frame(t(col2rgb(nodes_col, alpha = FALSE)))
# And add alpha (between 0 and 1). The alpha from "col2rgb" function takes values from 0-255, so we cannot use it
nodes_col_df <- cbind(nodes_col_df, alpha = rep(1, times = nrow(nodes_col_df)))
# Assign visual attributes to nodes (colors have to be 4dimensional - RGBA)
nodes_att_viz <- list(color = nodes_col_df, position = nodes_coord, size = nodes_size)
```

```{r edge attributes}
# Assign visual attributes to edges using the same approach as we did for nodes
F2 <- colorRampPalette(c("#FFFF00", "#006400"), bias = length(unique(E(gD)$weight)), space = "rgb", interpolate = "linear")

#These lines
colCodes <- F2(length(unique(E(gD)$weight)))
edges_col <- sapply(E(gD)$weight, function(x) colCodes[which(sort(unique(E(gD)$weight)) == x)])
edges_col_df <- as.data.frame(t(col2rgb(edges_col, alpha = FALSE)))
edges_col_df <- cbind(edges_col_df, alpha = rep(1, times = nrow(edges_col_df)))
edges_att_viz <-list(color = edges_col_df)

```

```{r}
# Write the network into a gexf (Gephi) file
#write.gexf(nodes = nodes_df, edges = edges_df, nodesAtt = nodes_att, edgesWeight = E(gD)$weight, edgesAtt = edges_att, nodesVizAtt = nodes_att_viz, edgesVizAtt = edges_att_viz, defaultedgetype = "undirected", output = "lesmis.gexf")
# And without edge weights
write.gexf(nodes = nodes_df, edges = edges_df, nodesAtt = nodes_att, edgesAtt = edges_att, nodesVizAtt = nodes_att_viz, defaultedgetype = "undirected", output = "mp-bib-coupling.gexf")
```

