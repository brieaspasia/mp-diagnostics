---
title: "mp-affiliations"
author: "Brie Sherow"
date: "14/07/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#references
#https://jokergoo.github.io/circlize_book/book/the-chorddiagram-function.html
```

```{r load libraries}
library(bibliometrix)
library(ggraph)
library(circlize)
library(tidyverse)
library(igraph)
```

```{r upload data, eval=TRUE}
getwd()
# bib <- convert2df(file = c("./data/scopus2015-2017.bib"), dbsource = "scopus", format = "bibtex") # Convert to a bibliometric data frame

bib <- convert2df(file = c("./data/scopus2018-2019.bib","./data/scopus2015-2017.bib", "./data/scopus2011-2014.bib","./data/scopus2006-2010.bib", "./data/scopus1999-2005.bib","./data/scopus1970-1998.bib"), dbsource = "scopus", format = "bibtex") # Convert to a bibliometric data frame
# names(bib)
# write.csv(bib, "output/bib_as_df.csv", row.names = FALSE) #save this data frame as a csv file
```


```{r university collab}

NetMatrix <- biblioNetwork(bib, analysis = "collaboration",  network = "universities", sep = ";")
net=networkPlot(NetMatrix,  n = 75, Title = "Author Affiliations", normalize = "salton", label.n=10, type = "fruchterman", halo=T, cluster="walktrap", size=10, size.cex=T,edgesize = 3,labelsize=1, remove.multiple=F, remove.isolates=F)

class(NetMatrix)

groups <- print(net$cluster_res)
```


```{r converting from matrix}
#convert to simple matrix
NetMatrix2 <- as.matrix(NetMatrix)

#convert to data frame
NetMatrix3 <- as.data.frame(NetMatrix2)

#add a column with university names from the rownames
NetMatrix3$University <- rownames(NetMatrix3)
head(NetMatrix3$University)

#reformat into long df
out <- gather(NetMatrix3, key = COL_NAME, value = Linkscount, -University)

#filter out self matches
out1 <- out[!(out$University==out$COL_NAME),]

#filter out low values
out2 <- out1 %>%
  filter(Linkscount >3)

#join to groups from net
out2$University <- tolower(as.character(out2$University))

#join to clustered groups
chord <- dplyr::left_join(out2, groups, by = c("University"="vertex"))

#rename columns
chord <- data.table::setnames(chord, old = c('University','COL_NAME','Linkscount'), new = c('from','to','value'))

#delete unnecessary columns
chord <- chord %>%
  select(from, to, value, cluster)

#check data
head(chord)

#select only top links
chord <- chord %>%
  arrange(desc(value)) %>%
  top_n(50)
    
```

#https://www.visualcinnamon.com/2014/12/using-data-storytelling-with-chord.html

```{r set parameters}
#example code from data-to-viz.com
circos.clear() #resets circular layout parameters
circos.par(start.degree = 90, gap.degree = 1, track.margin = c(-0.1, 0.1), points.overflow.warning = FALSE)
par(mar = rep(0, 4)) #set graphical parameters
```

```{r base chord diagram}

chordDiagram(chord,
             transparency = 0.25,
             directional=1,
             direction.type="diffHeight",
             diffHeight = -0.05,
             annotationTrack = "grid",
             preAllocateTracks = 1)


#circos text example https://www.data-to-viz.com/graph/chord.html

#grouping example fig 15.10 https://jokergoo.github.io/circlize_book/book/advanced-usage-of-chorddiagram.html#multiple-group-chord-diagram
```

```{r rename cluster for graph labels}
#original cluster groups from networkPlot
    from = c(1,2,3,5,7,8)
    
#mapping to geographical region
    to = c("China-centric", "UK-centric","USA and Australia", "Northern Europe", "Canada and Arctic", "Japan-centric")
    
    for(z in 1:length(from)){
      chord$cluster = plyr::mapvalues(chord$cluster, from = from[z], to = to[z])
    }
```



```{r igraph tutorial}
#https://davetang.org/muse/2017/03/16/matrix-to-adjacency-list-in-r/
# library(igraph)
# #ensuring no duplicated edges or self-loops
# bib_plot <- simplify(graph.data.frame(out, directed=FALSE))
```

```{r}
# # create igraph S3 object
# names(out) <- c('from', 'to', 'weight')
# 
# net <- graph.data.frame(out, directed = FALSE)
#  
# # store original margins
# orig_mar <- par()$mar
#  
# # set new margins to limit whitespace in plot
# par(mar=rep(.1, 4))
#  
# # not much difference in the edge width given the values
# plot(net, layout = layout_components(net), edge.width = E(net)$weight)
# plot(net, layout = layout_components(net), edge.width = E(net)$weight, vertex.shape="none")
```
```{r}
# # community detection based on edge betweenness (Newman-Girvan)
# ceb <- cluster_edge_betweenness(net)
#  
# plot(ceb, net)
#  
# # community membership for each node
# membership(ceb)
#  
# par(mar=orig_mar)
# dendPlot(ceb, mode="dendrogram")
# 
# plot_dendrogram(ceb, mode="phylo", colbar=palette())

```